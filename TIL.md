strands라는 프레임워크

## Agent란?
- 특정 목표를 달성하기 위해 스스로 계획하고 도구를 사용하며 환경과 상호작요
    - Q. 비결정적 프레임워크에서 어떻게 신뢰성 확보하고 중간에 컨트롤할 수 있으려나?
- langgraph는 흐름 설계 및 상태 전환을 개발자가 비교적 많이 제어함
- strands는 에이전트가 직접 판단하는 자율적 제어가 더 강조됨 -> 프로토타이핑 가능

## 실습
- Github 코드와 설명서의 예제를 통해서 진행함. cursor 환경이라서 자동완성을 더 많이 해줌

1. tools
- strands_tools에서 기본적으로 제공하는 tools를 할수도 있고, 커스텀도 되고 MCP도 가져올 수 있음
- Q.python_repl이란? python 코드를 실행하는 툴, file_write 툴은 파일을 쓰는 툴

2. docstring
- 메서드에 대한 설명글

3. MCP
- FastMCP는 MCP 서버와 클라이언트를 간단하게 생성할 수 있도록 설계된 고수준의 Pythonic 프레임워크
    - MCP를 만드는 클래스

- lambda를 써서 말늗ㄹ었음 MCPClient는 필요할때마다 새로운 연결을 만드는 클래스이나 laMBDA로 감싸면 나중에 필요할 때 실행함
- mcp서버를 띄우고 다른 터미널에 해야함!
- awscli 매번 export하거나 .env만드는걸 해야함..
- MCP 자체를 만드는 거라면 굳이 MCP를 만들어야할 이유가 뭐지..? 어떨때 MCP를 만드는가...MCP와 메서드의 차이점은? MCP 서버를 만드는 기준?
- MCP(Model Context Protocol)을 활용하면 단순히 애플리케이션 내부에 함수 하나 추가하는 것과 비교해 다음과 같은 장점이 있습니다:
    - 확장성 있는 연동: MCP 서버 하나에 여러 기능(도구)을 묶어 두고 클라이언트가 필요한 기능만 골라 쓰게 할 수 있습니다. 새로운 기능을 서버 쪽에만 추가하면 바로 클라이언트에서 활용 가능하므로 배포/확장이 쉽습니다.  
    - 기술 중립적 통합: 서로 다른 언어·프레임워크로 만든 여러 서비스나 유틸리티를 MCP 서버로 감싸 두면, 클라이언트는 공통 프로토콜로 호출할 수 있어 통합 비용이 줄어듭니다.  
    - 권한 제어와 격리: 기능을 네트워크 경계 밖으로 분리해 두면 접근 권한 관리, 로깅, 감시 등을 중앙에서 통제하기 쉬워집니다. 민감한 연산이나 리소스 접근을 서버 측에 두고 필요한 권한만 열어주는 식으로 구성할 수 있죠.  
    - 배포·운영 분리: 클라이언트와 서버를 분리하면 기능 수정 시 서버만 재배포하면 되고, 여러 클라이언트가 같은 MCP 서버를 공유할 수 있습니다. 함수 호출 기반 구조에서는 각 애플리케이션마다 함수를 복사·관리해야 하지만 MCP 서버는 재사용이 용이합니다.  
    - 상태·리소스 관리: 장기 실행 작업, 캐시, 연결 풀 등 상태ful 리소스를 서버에서 유지하면서 MCP를 통해 접근하게 하면 클라이언트는 단순한 프로토콜 호출만 처리하면 됩니다.

    - 정리하면, MCP는 기능을 네트워크 서비스로 캡슐화해 여러 클라이언트에서 표준 방식으로 재사용하고 확장할 수 있게 해주는 점이 가장 큰 이점입니다. 함수 수준 통합이 간단할 때도 있지만, 규모가 커지면 MCP 같은 프로토콜 기반 서버 구성이 더 유연하고 유지보수가 쉬워지는 경우가 많습니다.

4. 멀티 에이전트 시스템 & A2A(agent-to-agent)
- 여러 에이전트를 만들어서 각자의 일만 시키는 시스템
- 실습 예시
```
The Sage of Rules    ⚔️ Character Chronicler    🎲 Dice Oracle
           (Port 8000)              (Port 8001)            (Port 8080)
                │                        │                      │
                └────────────────────────┼──────────────────────┘
                                         │
                              👑 The Grand Orchestrator
                                   (Port 8009)
                                 [The Master's Throne]

```

- 8080이 MCP이면, 8000, 8001도 MCP인가
    - 아니었음. 에이전트를 메서드 기반으로 해도되고, 서버로 호출할 수도 있음
    - MCP를 해야할때란??
MCP는 “도구를 RPC 형태로 묶어 제공하는 중개층”, 에이전트 서버는 “대화형 모델이 외부에서 호출될 수 있도록 HTTP 등으로 노출된 LLM(orchestrator)”라고 보면 이해가 쉽습니다.

### MCP vs. 에이전트 서버

- **MCP 서버 (`http://127.0.0.1:8080/mcp`)**
  - MCP(Multi-Tool Capability Protocol)는 여러 도구를 표준화된 방식으로 노출하는 프로토콜입니다.
  - 클라이언트(여기서는 `MCPClient`)가 연결해 “제공 가능한 툴 목록”을 가져오고, 필요할 때 RPC처럼 호출합니다.
  - 장점: 툴 등록/탐색/호출이 규격화되어 있고, 도구 제공자·소비자 간 결합도가 낮습니다. 도구가 늘어나도 프로토콜이 같으니 확장성이 좋습니다.
  - 주 용도: “LLM이 다양한 툴(예: dice roll, 데이터 조회)을 일정한 인터페이스로 호출해야 할 때”.

- **에이전트 서버 (`http://127.0.0.1:8000`, `http://127.0.0.1:8001`)**
  - A2A(Agent-to-Agent) 프로토콜 등으로 HTTP API를 제공하는 별도 LLM/에이전트 서비스입니다.
  - 예제에서는 Rules Agent, Character Agent가 각각 독립 서버로 떠 있고, orchestrator가 HTTP로 질문을 전달합니다.
  - 장점: 각 에이전트가 고유한 문맥/프롬프트/기능을 갖고 독립적으로 운영되며, orchestrator는 해당 API를 호출해 협업을 조율합니다.

### 언제 MCP를 도입하는가?

- 많은 도구(roll dice, 외부 API, DB 연동 등)를 LLM이 “직접” 호출해야 하고, 이를 표준화·확장 가능한 방식으로 관리하고 싶을 때 MCP를 씁니다.
- 도구가 함수 단위(메서드 기반)로 존재하고, 동일한 프로토콜로 등록·발견·호출되어야 하는 상황.
- 반대로, 이미 독립적인 에이전트가 HTTP API로 잘 노출돼 있고, 그 에이전트 자체가 LLM과 대화하며 결과를 생성한다면 그냥 에이전트 서버 호출이 적절합니다.
- 결국 orchestrator는 “도구는 MCP로, 협업해야 하는 다른 대화형 에이전트는 HTTP(A2A)로” 섞어서 사용하는 패턴이 흔합니다.
---
- REST Client라는 편한 extention을 알게 되었습니다.